---
title: "MAT 400 Final Project"
author: "Aidan and Liam Greenlee"
subtitle: NBA Shot Prediction
---

```{r markdown, include=FALSE}
library(tidyverse)
require(gridExtra)
library(tidymodels)
library(dplyr)
library(e1071)
library(modelr)
library(caret)
library(lubridate)
library(tree)
library(glmnet)
```

## Data Exploration
```{r prep}
data <- na.omit(read.csv(file = "data.csv"))
data <- mutate(data,time_remaining = 60*minutes_remaining + seconds_remaining)
```
Here we are cleaning the data a little, combining minutes_remaining and seconds_remaining into one variable as well as omitting NA values.

```{r prep}
ggplot(data, aes(x=shot_distance, y = time_remaining,color=as_factor(shot_made_flag)))+geom_point()
```
It seems like shot_distance is related to shot_made_flag

```{r prep, echo=FALSE}
ggplot(data, aes(x=combined_shot_type,y = as_factor(shot_made_flag))) + geom_jitter()
```
This jitter plot shows that some shot types can be used t determine if the shot was made or missed. (dunks are usually made)

```{r prep, echo=FALSE}
ggplot(data, aes(x = lat, y = lon, color = shot_zone_area)) + geom_point() + coord_fixed(ratio = 1)# + theme(legend.position = "none")

ggplot(data, aes(x = lat, y = lon, color = as.factor(shot_made_flag))) + geom_point() + coord_fixed(ratio = 1)# + theme(legend.position = "none")
```
It seems like shots from the back of the court are almost always missed. This is could be a good predictor

```{r prep, echo=FALSE}
ggplot(data, aes(x=loc_x,y=loc_y, color = shot_distance)) + geom_point() + coord_fixed(ratio = 1) + scale_colour_gradientn(colours=rainbow(100))
```

The exploration indicates thate the best predictors could be shot distance, combined shot type, and maybe shot zone area.

## Splitting Data
```{r split, results='hide'}

#data$shot_made_flag <- as.factor(data$shot_made_flag)
dataUsed <- data[,c(2,9,6,7,10,14,15,16,17,18,24,26)]
resample <- initial_split(prop = .7, dataUsed)
test <- testing(resample)
train <- training(resample)
```

The data is split into test and train sets.
We omitted some columns that include information from other columns or were not important (game id, shot id, etc.)

## XGBOOST
```{r, echo=FALSE}
library(xgboost)

priorProbability <- sum(data$shot_made_flag)/nrow(data)
```


```{r}
nfold <- 10
m <- model.matrix(shot_made_flag~., data = train)
m2 <- model.matrix(shot_made_flag~., data = test)
```

An xgboost model is used with 10 fold cross validation.

```{r}
xgboostmodel <- xgb.cv(data = m, prediction = TRUE, callbacks = list(cb.cv.predict(save_models = TRUE)), label = train$shot_made_flag, nfold = nfold, nrounds = 1000, verbose = 1, objective = "binary:logistic", early_stopping_rounds = 10)
```

```{r}
predserr <- data.frame(numeric(nfold))
xgboostmodel
```


```{r, include=FALSE}
xgboostmodel$models
```

Here, we are performing cross validation on xgboost to choose the best model.
```{r}
for(i in 1:nfold) { 
model <- xgb.Booster.complete(xgboostmodel$models[[i]])

test$pred <- predict(model, m2)
test <- test %>% mutate(prediction = ifelse(pred > (1-priorProbability), 1, 0))
test <- test %>% mutate(correct = ifelse(prediction == shot_made_flag, 1, 0))
predserr$numeric.nfold.[i] <- 1-sum(test$correct)/nrow(test)
}

n <- which.min(predserr$numeric.nfold.)
predserr
bestmodel <- xgb.Booster.complete(xgboostmodel$models[[n]])
predserr$numeric.nfold.[n]
```

The misclassification rate of this model is ~ 40%.
Some more models will be tested.

```{r}
glm_fit <- glm(shot_made_flag ~ .,
    data = train,
    family = binomial
)
```

```{r}
testPred <- test
testPred <- testPred %>% add_predictions(glm_fit) %>% mutate(prob = exp(pred)/ (1 + exp(pred)))

testPred <- testPred %>% 
    mutate(shot_made = ifelse(prob > 0.5, 1, 0))
testPred %>% count(shot_made_flag, shot_made) %>% spread(shot_made_flag, n)


library(tidymodels)
autoplot(roc_curve(testPred, as.factor(shot_made_flag), prob))
roc_auc(testPred, as.factor(shot_made_flag), prob)

# tidyverse

testPred <- testPred %>% mutate(correct = ifelse(shot_made == shot_made_flag, 1, 0))
1-sum(testPred$correct)/nrow(testPred)
```
## GENERALIZED LINEAR MODEL
```{r}
testPred <- test
glmModel <- train(as.factor(shot_made_flag)~ ., train, method = 'glm', family = binomial, trControl = trainControl(method = 'cv', number = 5))

testPred <- testPred%>%add_predictions(glmModel)

testPred <- testPred %>% mutate(correct = ifelse(pred == shot_made_flag, 1, 0))
1-sum(testPred$correct)/nrow(testPred)

```
## LINEAR DISCRIMINANT ANALYSIS
```{r}
testPred <- test
ldaModel <- train(as.factor(shot_made_flag) ~ ., data=train, method="lda", trControl = trainControl(method = "cv", number = 5))

testPred <- testPred%>%add_predictions(ldaModel)

testPred <- testPred %>% mutate(correct = ifelse(pred == shot_made_flag, 1, 0))
1-sum(testPred$correct)/nrow(testPred)
```
## XGBOOST
```{r}
library(xgboost)

priorProbability <- sum(data$shot_made_flag)/nrow(data)
nfold <- 50
m <- model.matrix(shot_made_flag~., data = train)
m2 <- model.matrix(shot_made_flag~., data = test)
```

an xgboost model is used with cross validation

```{r}
xgboostmodel <- xgb.cv(data = m, prediction = TRUE, callbacks = list(cb.cv.predict(save_models = TRUE)), label = train$shot_made_flag, nfold = nfold, nrounds = 1000, verbose = 1, objective = "binary:logistic", early_stopping_rounds = 10)
```
```{r}
predserr <- data.frame(numeric(nfold))
xgboostmodel
xgboostmodel$models
for(i in 1:nfold) { 
model <- xgb.Booster.complete(xgboostmodel$models[[i]])

test$pred <- predict(model, m2)
test <- test %>% mutate(prediction = ifelse(pred > (1-priorProbability), 1, 0))
test <- test %>% mutate(correct = ifelse(prediction == shot_made_flag, 1, 0))
predserr$numeric.nfold.[i] <- 1-sum(test$correct)/nrow(test)
}

n <- which.min(predserr$numeric.nfold.)
predserr
bestmodel <- xgb.Booster.complete(xgboostmodel$models[[n]])
predserr$numeric.nfold.[n]
```
## BAYES GLM
```{r}
testPred <- test
treebagModel <- train(as.factor(shot_made_flag) ~ ., data=train, method="bayesglm", trControl = trainControl(method = "cv",number = 5))

testPred <- testPred%>%add_predictions(treebagModel)

testPred <- testPred %>% mutate(correct = ifelse(pred == shot_made_flag, 1, 0))
1-sum(testPred$correct)/nrow(testPred)
```
```{r}
testPred <- test
treebagModel <- train(as.factor(shot_made_flag) ~ ., data=train, method="nnet", trControl = trainControl(method = "cv",number = 5))

testPred <- testPred%>%add_predictions(treebagModel)

testPred <- testPred %>% mutate(correct = ifelse(pred == shot_made_flag, 1, 0))
1-sum(testPred$correct)/nrow(testPred)
```

```{r}
testPred <- test
train$shot_made_flag <- as_factor(train$shot_made_flag)
treefit <- tree(data = train, shot_made_flag ~ .  -opponent, method = "misclass")
plot(treefit)
text(treefit, all = TRUE, cex = .7)
```


```{r}
fittree <- cv.tree(treefit, method = "misclass")
plot(fittree$size, fittree$dev, type = "b")

prune_fit <- prune.misclass(treefit, best = 3)
plot(prune_fit, type = "uniform")
text(prune_fit, all = TRUE, cex = .7)

testPred %>% modelr::add_predictions(prune_fit, type = "class") %>%
    accuracy(as.factor(shot_made_flag), pred)
```